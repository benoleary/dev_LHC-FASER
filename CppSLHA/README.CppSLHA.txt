/*
 * CppSLHA's README.CppSLHA.txt
 *
 *  Created on: 25 Oct 2010
 *      Author: Ben O'Leary (benjamin.oleary@gmail.com)
 *      Copyright 2010 Ben O'Leary
 *
 *      This file is part of CppSLHA.
 *
 *      CppSLHA is free software: you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation, either version 3 of the License, or
 *      (at your option) any later version.
 *
 *      CppSLHA is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with CppSLHA.  If not, see <http://www.gnu.org/licenses/>.
 *
 *      The GNU General Public License should be in GNU_public_license.txt
 *      the files of CppSLHA are:
 *      CppSLHA.hpp
 *      CppSLHA.cpp
 *      CppSLHA_BLOCK.hpp
 *      CppSLHA_BLOCK.cpp
 *      CppSLHA_EW_scale_spectrum.hpp
 *      CppSLHA_EW_scale_spectrum.cpp
 *      CppSLHA_file_reading_stuff.hpp
 *      CppSLHA_file_reading_stuff.cpp
 *      CppSLHA_global_stuff.hpp
 *      CppSLHA_global_stuff.cpp
 *      CppSLHA_PDG_codes_and_data.hpp
 *      CppSLHA_PDG_codes_and_data.cpp
 *      CppSLHA_particle_data.hpp
 *      CppSLHA_particle_data.cpp
 *      CppSLHA_waiting_on_subprocess_executor.hpp
 *      CppSLHA_waiting_on_subprocess_executor.cpp
 *      and README.CppSLHA.txt which describes the package.
 *
 */

/*
 * Changelog below documentation.
 */


/*********************************************************************
 *                                                                   *
 * IMPORTANT!                                                        *
 *                                                                   *
 * welcome, person who has decided to read this file.                *
 *                                                                   *
 * FIRST OF ALL: rather perversely, I put the files for the various  *
 * classes in a subdirectory to keep them out of the way. I hate     *
 * directories full of hundreds of different .hpp & .cpp files.      *
 * therefore I put them in CppSLHA_stuff, so if you use CppSLHA,     *
 * you will need to put a line in your makefile to include the .cpp  *
 * files in the ./CppSLHA_stuff/ directory.                          *
 *                                                                   *
 * I hope that you will find these classes easy to use. I have       *
 * tried to make the variable names self-explanatory, & hope that    *
 * the comments are adequate to explain the logic of the code.       *
 *                                                                   *
 * all dimensionful quantities in the code are assumed to be in GeV. *
 *                                                                   *
 * the logic of this class is that it reads in an SLHA-format file   *
 * generated by SPheno or SUSY-HIT (SDECAY+SUSPECT) or SOFTSUSY or   *
 * similar, stores the data internally & gives out data roughly as   *
 * someone would ask someone else to read out an entry from the file *
 * (e.g. "please find the SMINPUTS BLOCK then tell me the value at   *
 * entry 3"). it makes no attempt to make it any more intuitive      *
 * than that, it just adheres to the SLHA standard.                  *
 *                                                                   *
 *                                                                   *
 * usage instructions:                                               *
 * create an instance of a CppSLHA0-derived class, providing the     *
 * name of the SLHA-format file which it will read, then call its    *
 * read_file() function.                                             *
 * note the CppSLHA namespace!                                       *
 * e.g.:                                                             *
 * std::string eg_SLHA_file_name = "../spectra/SPheno.spc"           *
 * CppSLHA::CppSLHA1 eg_object( eg_SLHA_file_name );                 *
 * eg_object.read_file();                                            *
 * if read_file( std::string new_file_name ) is used, it will read   *
 * in the new file, as might be guessed. it discards all             *
 * previously-read data though.                                      *
 *                                                                   *
 * the basic CppSLHA0 class itself only stores masses and decays.    *
 * these are accessed through get_MASS( int particle_PDG_code ),     *
 * which returns the mass as a double, or                            *
 * get_DECAY( int particle_PDG_code ), which returns a pointer to    *
 * an instance of a particle_decay_set_handler (see                  *
 * ./CppSLHA_stuff/particle_data.hpp for more information on         *
 * particle_decay_set_handler), of the particle which has            *
 * particle_PDG_code as its code according to the PDG (as long as    *
 * this code was found in the SLHA-format file which was read, or    *
 * was a default particle in the EW_scale_spectrum instance provided *
 * to the CppSLHA0 constructor).                                     *
 * e.g.: get_MASS( 24 ) will return the mass of the charged W boson  *
 * as a double, if the EW_scale_spectrum instance knows about it,    *
 * either from its constructor or from its mass being read in from   *
 * the SLHA-format file's MASS BLOCK.                                *
 * a list of the PDG particle codes is in                            *
 * ./CppSLHA_stuff/particle_data.hpp in the #define list.            *
 *                                                                   *
 * if no EW_scale_spectrum is provided to the CppSLHA0 constructor,  *
 * an MSSM spectrum is assumed. see below about using non-MSSM       *
 * spectra.                                                          *
 *                                                                   *
 *                                                                   *
 * there are derived classes, which then allow more information from *
 * an SLHA-format file to be stored. feel free to write your own,    *
 * following the default provided examples: CppSLHA1, CppSLHA2 &     *
 * CppSLHA2_SPheno.                                                  *
 *                                                                   *
 * the derived classes should be used in the following way:          *
 * masses are still found using get_MASS( int particle_PDG_code ),   *
 * decays are still found using get_DECAY( int particle_PDG_code ),  *
 * while other BLOCKs are found using                                *
 * get_BLOCK( std::string BLOCK_name ), which returns a pointer to   *
 * the SLHA_BLOCK with name BLOCK_name, then one should use          *
 * get_entry( int element1, int element2, ... ) with the appropriate *
 * number of elements (1, 2 or 3; for a BLOCK with more indices, one *
 * has to code it oneself). e.g. for SMINPUTS, which has a single    *
 * index, one would use get_BLOCK( "SMINPUTS" )->get_entry( 1 ) to   *
 * get the entry labelled 1 (which is 1/alpha_EM at the Z mass in    *
 * the MSbar scheme). however, BE CAREFUL that the BLOCK exists or   *
 * you may end up with segmentation faults as you attempt to use     *
 * ->get_entry() on a NULL pointer.                                  *
 * also available are the various                                    *
 * set_entry( int element1, int element2, ..., double input )        *
 * functions to overwrite the entries.                               *
 *                                                                   *
 * ALSO BE AWARE THAT ALL BLOCKS ARE KNOWN WITHIN THE CODE BY        *
 * STRINGS OF ALL UPPERCASE! e.g. get_BLOCK( "SMINPUTS" ) will       *
 * return the SMINPUTS BLOCK if it exists BUT                        *
 * get_BLOCK( "sminputs" ) will return NULL regardless of whether    *
 * SMINPUTS exists or not.                                           *
 * (this is a quirk due to some calculators calling them BLOCKs,     *
 * some Blocks, etc., & I decided to go with converting all the      *
 * characters to uppercase while reading in the lines to make my     *
 * life easier.)                                                     *
 * ALSO NOTE THAT REGARDLESS OF WHAT YOU CALL A BLOCK IN DERIVED     *
 * CLASSES, INTERNALLY ITS NAME WILL BE RECORDED IN UPPERCASE.       *
 * e.g. if you decide to write a derived class which extends         *
 * CppSLHA1 with a new BLOCK which you want to call myBlock, & in    *
 * its constructor / in its initialize() (I would advise writing an  *
 * initialize function to avoid duplicating code across the 2        *
 * constructors, if you are using them), you put                     *
 * BLOCK_adder = new one_index_BLOCK( "myBlock",                     *
 *                                "this is different to mYbLOCK" );  *
 * BLOCKs.push_back( BLOCK_adder );                                  *
 * BLOCK_adder = new one_index_BLOCK( "mYbLOCK",                     *
 *                                "this is different to myBlock" );  *
 * BLOCKs.push_back( BLOCK_adder );                                  *
 * THIS WILL NOT WORK. you will end up with 2 BLOCKs called MYBLOCK  *
 * & the 1st found in the SLHA file will be recorded in it, while    *
 * the 2nd will be in get_extra_BLOCK() as described below, BUT      *
 * IT WILL BE COMPLETELY DEPENDENT ON THE ORDER WHICH THEY WERE READ *
 * IN FROM THE FILE.                                                 *
 *                                                                   *
 * if a BLOCK exists more than once in the SLHA file (if there are   *
 * multiple BLOCKs with the same name), then it is recorded under    *
 * the first such BLOCK with that name & subsequent BLOCKs (such as  *
 * the same BLOCK with a different Q) are obtained by the            *
 * get_extra_BLOCK() function.                                       *
 * e.g., the SLHA file has MSOFT Q= 1.00000000E+002 & also           *
 * MSOFT Q= 2.00000000E+002 BLOCKs. that which appeared first in the *
 * file is that obtained by get_BLOCK( "MSOFT" ), while the next     *
 * recorded is obtained by get_BLOCK( "MSOFT" )->get_extra_BLOCK(),  *
 * while a 3rd would be found with                                   *
 * get_BLOCK( "MSOFT" )->get_extra_BLOCK()->get_extra_BLOCK()        *
 * please check that the extra BLOCKs exist with has_extra_BLOCK()   *
 * before doing anything which would break if a NULL pointer was     *
 * returned for the extra BLOCK (which is the default return if the  *
 * extra BLOCK does not exist).                                      *
 *                                                                   *
 * CppSLHA1                                                          *
 * this prepares the BLOCKS MODSEL, SMINPUTS, MINPAR, EXTPAR, NMIX,  *
 * UMIX, VMIX, STOPMIX, SBOTMIX, STAUMIX, ALPHA, HMIX, GAUGE, MSOFT, *
 * AU, AD, AE, YU, YD, YE & SPINFO, which are those described in the *
 * 1st SLHA paper, P. Skands et al., JHEP 0407:036,2004,             *
 * http://arxiv.org/abs/hep-ph/0311123 online.                       *
 *                                                                   *
 * CppSLHA2                                                          *
 * this prepares all the CppSLHA BLOCKs, & also those mentioned in   *
 * the SLHA2 paper:                                                  *
 * B. C. Allanach et al., Comp.Phys.Commun.180:8-25,2009,            *
 * http://arxiv.org/abs/0801.0045 online.                            *
 * it extends the comments on SMINPUTS & EXTPAR as well.             *
 * the extra BLOCKs are: IMMINPAR, IMEXTPAR, IMNMIX, IMUMIX, IMVMIX, *
 * IMSTOPMIX, IMSBOTMIX, IMSTAUMIX, IMALPHA, IMHMIX, IMGAUGE,        *
 * IMMSOFT, IMAU, IMAD, IMAE, IMYU, IMYD, IMYE, QEXTPAR, VCKMIN,     *
 * IMVCKMIN, UPMNSIN, IMUPMNSIN, MSQ2IN, IMMSQ2IN, MSU2IN, IMMSU2IN, *
 * MSD2IN, IMMSD2IN, MSL2IN, IMMSL2IN, MSE2IN, IMMSE2IN, (MSN2IN,    *
 * IMMSN2IN,) TUIN, IMTUIN, TDIN, IMTDIN, TEIN, IMTEIN, (TNIN,       *
 * IMTNIN,) MSQ2, IMMSQ2, MSU2, IMMSU2, MSD2, IMMSD2, MSL2, IMMSL2,  *
 * MSE2, IMMSE2, (MSN2, IMMSN2,) TU, IMTU, TD, IMTD, TE, IMTE, (TN,  *
 * IMTN,) VCKM, IMVCKM, UPMNS, IMUPMNS, USQMIX, IMUSQMIX, DSMIX,     *
 * IMDSMIX, SELMIX, IMSELMIX, SNUMIX, IMSNUMIX, SNSMIX, IMSNSMIX,    *
 * SNAMIX, IMSNAMIX, RVLAMLLEIN, IMRVLAMLLEIN, RVLAMLQDIN,           *
 * IMRVLAMLQDIN, RVLAMUDDIN, IMRVLAMUDDIN, RVLAMLLE, IMRVLAMLLE,     *
 * RVLAMLQD, IMRVLAMLQD, RVLAMUDD, IMRVLAMUDD, RVTLLEIN, IMRVTLLEIN, *
 * RVTLQDIN, IMRVTLQDIN, RVTUDDIN, IMRVTUDDIN, RVTLLE, IMRVTLLE,     *
 * RVTLQD, IMRVTLQD, RVTUDD, IMRVTUDD, RVKAPPAIN, IMRVKAPPAIN,       *
 * RVDIN, IMRVDIN, RVSNVEVIN, IMRVSNVEVIN, RVM2LH1IN, IMRVM2LH1IN,   *
 * RVKAPPA, IMRVKAPPA, RVD, IMRVD, RVSNVEV, IMRVSNVEV, RVM2LH1,      *
 * IMRVM2LH1, RVNMIX, IMRVNMIX, RVUMIX, IMRVUMIX, RVVMIX, IMRVVMIX,  *
 * RVHMIX, IMRVHMIX, RVAMIX, IMRVAMIX, RVLMIX, IMRVLMIX, CVHMIX,     *
 * IMCVHMIX, NMSSMRUN, NMHMIX, IMNMHMIX, NMAMIX, IMNMAMIX, NMNMIX, & *
 * IMNMNMIX.                                                         *
 *                                                                   *
 * CppSLHA2_SPheno                                                   *
 * this prepares all the BLOCKs from CppSLHA2, & also BLOCKs for     *
 * the SPheno-specific information: SPHENOINFO; SPheno-specific      *
 * input: SPHENOINPUT, cross-sections as calculated by SPheno:       *
 * SPHENOCROSSSECTIONS; and low energy observables as calculated by  *
 * SPheno: SPHENOLOWENERGY.                                          *
 * a few words on the additional types of BLOCK introduced for       *
 * SPheno:                                                           *
 * while it may seem that the SPHENOINPUT BLOCK should only have a   *
 * single index, the feature that the lepton collider cross-section  *
 * information may be given multiple times means that actually each  *
 * entry has an associated "hidden" index, which labels which        *
 * occurrence of the entry it is. the entries are accessed with      *
 * has_entry( int, double* ) & has_entry( int, int, double* ). the   *
 * latter takes the index as explicitly written as its 1st argument  *
 * & the occurrence as the 2nd argument. the former takes the index  *
 * as explicitly written as its 1st argument & sets the hidden index *
 * to 1. the overloaded function set_entry works similarly.          *
 * the SPHENOCROSSSECTIONS BLOCK could have a more comprehensive     *
 * structure, but I have no desire to sort it out any more. as it    *
 * is, one can use the CppSLHA2_SPheno function                      *
 * get_SPheno_cross_sections_BLOCK() to access it. then one can      *
 * access the specific data structures though e.g.                   *
 * SPheno_cross_sections_BLOCK* sigma                                *
 *                            = get_SPheno_cross_sections_BLOCK();   *
 * sigma->get_SPheno_cross_section_vector();                         *
 * see the comments in CppSLHA_BLOCK.hpp for explanations of how the *
 * cross-sections are stored & accessed.                             *
 *                                                                   *
 *                                                                   *
 * NMSSM or other non-standard SUSY model:                           *
 * 1st extend the EW_scale_spectrum class as necessary (see the      *
 * class definition of EW_scale_NMSSM_spectrum in                    *
 * ./CppSLHA_stuff/EW_scale_spectrum.hpp for an example of how to do *
 * this for the NMSSM). then, in the code, create an instance of     *
 * this class, then pass a pointer to this spectrum as the 2nd       *
 * argument of the CppSLHA constructor.                              *
 * e.g.                                                              *
 * CppSLHA::EW_scale_spectrum* eg_spectrum;                          *
 * eg_spectrum = new CppSLHA::eg_extended_SSM_spectrum();            *
 * CppSLHA::CppSLHA egSLHAdata( "/path/SPheno.spc", eg_spectrum );   *
 * double x = egSLHAdata.get_MASS( 123456789 );                      *
 * x will now be the mass of the new particle in the                 *
 * eg_extended_SSM_spectrum which has been given the number          *
 * 123456789 as its PDG particle code. if /path/SPheno.spc did not   *
 * have an entry for 123456789 in its MASS BLOCK, x will be NaN, and *
 * a warning message will have been printed out.                     *
 * note that the CppSLHA object stores a copy of the given spectrum  *
 * internally in the state it was given, & does not update for any   *
 * later changes to the spectrum used as the constructor's argument. *
 * this means that in the case that the CppSLHA object was given     *
 * myNewSpectrum as an argument & later myNewSpectrum added in a new *
 * particle, the CppSLHA won't know about the change. in that case,  *
 * I think the best thing to do is delete the CppSLHA & make a new   *
 * one with the updated spectrum.                                    *
 *                                                                   *
 *                                                                   *
 * writing output:                                                   *
 * there is a function                                               *
 * write_file( std::string output_SLHA_file_name ) (& an overloaded  *
 * version where a std::list< std::string >* is given with a subset  *
 * of BLOCKs if the user wishes to restrict what is written out)     *
 * which creates a file with the given name & then writes out all    *
 * the BLOCKs.                                                       *
 *                                                                   *
 * also, there is a function, draw_spectrum, to produce a visual of  *
 * representation the sparticle spectrum. paths to the executables   *
 * for gnuplot, latex, dvips, & ps2eps are needed, or, if none are   *
 * specified, they are all assumed to be found in the /usr/bin/      *
 * directory. ps2epsi can also be used instead of ps2eps, but the    *
 * user must ensure that the correct executable name gets passed to  *
 * draw_spectrum!                                                    *
 * example code which produces a stand-alone executable which reads  *
 * in an SLHA-format particle spectrum & uses draw_spectrum to       *
 * produce a .eps file for the spectrum should be available from the *
 * same place as the rest of the CppSLHA files.                      *
 * the main source file is CppSLHA_spectrum_drawer.cpp, & there      *
 * should also be CppSLHA_spectrum_drawer.README, which is the       *
 * manual for the spectrum drawer executable.                        *
 *                                                                   *
 *                                                                   *
 * FURTHER NOTES:                                                    *
 * NaN (Not a Number) is returned in most cases where a value has    *
 * requested but it has not been recorded, which should be a really  *
 * obvious "error flag" (also, error messages are printed out if     *
 * unrecorded values are requested).                                 *
 *                                                                   *
 *                                                                   *
 * NOT IMPLEMENTED:                                                  *
 * currently, this code does not record BLOCKs which have names it   *
 * does not recognize. it just prints out a warning message & goes   *
 * on to read the next BLOCK.                                        *
 *                                                                   *
 *********************************************************************/

/*
 * Changelog:
 *
 * 2011-06-08
 * 1.2.2 - Minor changes:
 *         - a comparison to std::string::npos in a SPheno-specific BLOCK
 *           thing was possibly always evaluating to true because an unsigned
 *           int was being used; fixed by using a std::size_t instead.
 *
 * 2011-04-27
 * 1.2.1 - Major changes:
 *         - oops, SPheno at least is unhappy with the MODSEL BLOCK entries
 *           given as doubles. changed so that BLOCKs can be specified to
 *           print out their entries as ints rather than doubles.
 *           (using SLHA_BLOCK::write_entry_as_integer(), which defaults to
 *           writing as doubles, but CppSLHA1 etc. have MODSEL set to writing
 *           doubles in the constructor.)
 *         - also oops, changing values of BLOCK entries was not accounted for
 *           by get_as_string(), so this was fixed.
 *       - Minor changes:
 *         - rearranged ordering of stuff in initialization lists & put in lots
 *           of casting to unsigned ints to remove all compilation warnings.
 *
 * 2011-04-07
 * 1.2.0 - Major changes:
 *         - fixed bug about not working on OS X. it now should compile & run
 *           on Macs!
 *         - fixed bug where
 *           waiting_on_subprocess_executor::fork_and_execv_and_wait()
 *           would sometimes appear to just not work (the child process
 *           was actually ending with segmentation faults, but because
 *           it was the child, the error message was not being displayed).
 *         - strings are now passed around by pointer rather than by value,
 *           & functions return const pointers to strings, with a few
 *           exceptions. the functions returning strings rather than pointers:
 *           - SPheno_cross_section_set::get_as_string()
 *           - EW_scale_spectrum::get_decay_as_string(...)
 *           - CppSLHA_global::SLHA_double(...)
 *           - CppSLHA_global::SLHA_int(...)
 *           - CppSLHA0::get_MASS_as_string()
 *           - CppSLHA0::get_DECAY_as_string()
 *       - Minor changes:
 *         - moved all inline functions definitions out of class definitions
 *           down to after all the class definitions in the relevant header
 *           files. some larger functions had the inline keyword removed &
 *           were moved to the relevant source files.
 *
 * 2011-01-21
 * 1.1.0 - Major changes:
 *         - file structure is now that the tarball is just the CppSLHA
 *           directory, within it directly are all the files (no more
 *           CppSLHA_stuff directory).
 *         - all #defined quantities have been replaced by static const
 *           variables.
 *         - reading in the file now uses a hash_commented_file_reader
 *           class, which doesn't particularly help CppSLHA (it only gets
 *           used once), but is handy for classes using CppSLHA.
 *         - gave EW_scale_SM_spectrum, EW_scale_MSSM_spectrum,
 *           EW_scale_FVMSSM_spectrum, EW_scale_NMSSM_spectrum,
 *           & EW_scale_FVNMSSM_spectrum their own shortcuts to particle
 *           pointers.
 *         - changed to more intuitively store all data in the
 *           EW_scale_spectrum given if it is constructed with a pointer
 *           to an EW_scale_spectrum instance, while still holding a copy
 *           of the given EW_scale_spectrum, which is restored to the given
 *           pointer with CppSLHA0::reset().
 *       - Minor changes:
 *         - added to CppSLHA0::
 *           -- inline EW_scale_spectrum const*
 *              inspect_particle_spectrum()
 *              const
 *           -- SLHA_BLOCK const*
 *              inspect_BLOCK( std::string requested_BLOCK )
 *              const
 *         - a typo in the FVMSSM spectrum was fixed (sdown_two was 1000002,
 *           fixed to be 1000003, sdown_three was 1000003, fixed to be
 *           1000005).
 *
 * 2010-12-14
 * 1.0.3 - Minor changes:
 *         - fixed bug with reset not resetting has_recorded_flag (meaning
 *           reading in a 2nd file led to every BLOCK being designated an
 *           extra_BLOCK)
 *         - added ability to use get_BLOCK( "MASS" ) without having to
 *           treat masses specially
 *         - attempted fix for uppercase-transformation of strings so that
 *           it doesn't have to use voodoo any more & may even now work on
 *           Macs.
 *           -- UPDATE: the fix doesn't help Macs to compile. well, it
 *                      does, but the kill command used by
 *                      waiting_on_subprocess_executor is unknown to at
 *                      least some compilers in a Mac terminal, so it looks
 *                      like there won't be any Mac-compatible version
 *                      until I look deeper into the issue.
 *
 * 2010-12-13
 * 1.0.2 - Minor changes:
 *         - a typo in the FVMSSM spectrum was fixed (sup_six was
 *           "${\\tilde{d}}_{u}$", fixed to be "${\\tilde{u}}_{6}$").
 *
 * 2010-12-13
 * 1.0.1 - Minor changes:
 *         - draw_spectrum now tries to copy both
 *           CppSLHA_gnuplot_LaTeX.proper.eps &
 *           CppSLHA_gnuplot_LaTeX.proper.epsi to the target output filename,
 *           so that whichever of ps2eps or ps2epsi was used still works.
 *
 * 2010-12-12
 * 1.0.0 - First release!
 */
